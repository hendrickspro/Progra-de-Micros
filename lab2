// Lab 2 - Contador de segundos con comparación y LED
// Angel Ortiz - 24377
// F-cpu = 1 MHz
// Timer0 - 100ms
// Contador de segundos que se compara con contador de botones

.include "M328PDEF.inc"

.def temp = r17

.dseg
.org SRAM_START
counter_buttons: .byte 1  // Contador controlado por botones (0-15)
counter_seconds: .byte 1  // Contador de segundos (0-15)
timer_ticks:     .byte 1  // Contador de ticks de 100ms (0-9)
led_state:       .byte 1  // Estado del LED (0 o 1)

.cseg
.org 0x0000
    rjmp Reset

// Tabla para display de 7 segmentos CÁTODO COMÚN (0-F hexadecimal)
// Conexión: A=PD0, B=PD1, C=PD2, D=PD3, E=PD4, F=PD5, G=PD6
.org 0x0040
table7seg: .DB 0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71
//             0     1     2     3     4     5     6     7     8     9     A     b     C     d     E     F

.org 0x0050
Reset:
    // Inicializar Pila
    ldi temp, HIGH(RAMEND)
    out SPH, temp
    ldi temp, LOW(RAMEND)
    out SPL, temp

    // Disable UART
    ldi r16, 0x00
    sts UCSR0B, r16

    // Setting prescaler del CPU
    ldi r16, (1 << CLKPCE)
    sts CLKPR, r16
    ldi r16, 0b00000100
    sts CLKPR, r16

    // Configurar PORTD como salidas (Display de 7 segmentos)
    ldi temp, 0b01111111
    out DDRD, temp

    // Configurar PORTC como salidas (PC0-PC3 para contador de segundos)
    ldi temp, 0b00001111
    out DDRC, temp

    // Configurar PB0 y PB1 como entradas con pull-up, PB4 como salida (LED)
    cbi DDRB, DDB0
    cbi DDRB, DDB1
    sbi DDRB, DDB4              // PB4 como salida para LED
    sbi PORTB, PORTB0
    sbi PORTB, PORTB1
    cbi PORTB, PORTB4           // LED inicialmente apagado

    // Inicializar variables
    ldi r16, 0
    sts counter_buttons, r16
    sts counter_seconds, r16
    sts timer_ticks, r16
    sts led_state, r16

    // Configurar Timer0 - Modo Normal - Prescaler 1024
    ldi temp, 0x00
    out TCCR0A, temp
    ldi temp, (1 << CS02) | (1 << CS00)
    out TCCR0B, temp

    // Mostrar valor inicial en display
    call Update_display

Main_loop:
    // Verificar botón B1 (PB0) - Incremento
    sbis PINB, PINB0
    call Button_increment

    // Verificar botón B2 (PB1) - Decremento
    sbis PINB, PINB1
    call Button_decrement

    // Delay de 100ms usando Timer0
    call Delay_100ms

    // Incrementar contador de ticks
    lds r16, timer_ticks
    inc r16
    cpi r16, 10              // Verificar si llegó a 10 (1 segundo)
    brlo Save_ticks
    
    // Si llegó a 10 ticks (1 segundo), reiniciar ticks e incrementar segundos
    clr r16
    call Increment_seconds

Save_ticks:
    sts timer_ticks, r16

    rjmp Main_loop

Button_increment:
    push r16
    push r17

    // Anti-rebote: esperar a que se suelte el botón
Wait_release_inc:
    sbis PINB, PINB0
    rjmp Wait_release_inc

    // Delay adicional para anti-rebote
    call Delay_50ms

    // Incrementar contador de botones
    lds r17, counter_buttons
    inc r17
    
    // Verificar si pasó de 15
    cpi r17, 16
    brlo Save_inc
    ldi r17, 0

Save_inc:
    sts counter_buttons, r17
    call Update_display

    pop r17
    pop r16
    ret

Button_decrement:
    push r16
    push r17

    // Anti-rebote: esperar a que se suelte el botón
Wait_release_dec:
    sbis PINB, PINB1
    rjmp Wait_release_dec

    // Delay adicional para anti-rebote
    call Delay_50ms

    // Decrementar contador de botones
    lds r17, counter_buttons
    dec r17
    
    // Verificar si pasó de 0 (underflow)
    cpi r17, 0xFF
    brne Save_dec
    ldi r17, 15

Save_dec:
    sts counter_buttons, r17
    call Update_display

    pop r17
    pop r16
    ret

Increment_seconds:
    push r16
    push r17
    push r18

    // Incrementar contador de segundos (Leds 4 bits)
    lds r16, counter_seconds
    inc r16
    andi r16, 0x0F           // Limitar a 4 bits (0-15)
    sts counter_seconds, r16

    // Mostrar contador de segundos en PORTC (bits 0-3)
    out PORTC, r16

    // Comparar contador de segundos con contador de botones
    lds r17, counter_buttons
    cp r16, r17
    brne No_match            // Si no coinciden, salir

    // Si coinciden, reiniciar contador de segundos y toggle LED
    clr r16
    sts counter_seconds, r16
    out PORTC, r16           // Actualizar PORTC con el contador en 0

    // Toggle del LED en PB4
    lds r18, led_state
    cpi r18, 0
    breq Turn_on_led

    // Apagar LED
    clr r18
    cbi PORTB, PORTB4
    rjmp Save_led_state

Turn_on_led:
    ldi r18, 1
    sbi PORTB, PORTB4

Save_led_state:
    sts led_state, r18

No_match:
    pop r18
    pop r17
    pop r16
    ret

Update_display:
    push r16
    push r17
    push r30
    push r31

    // Cargar valor del contador de botones
    lds r17, counter_buttons
    
    // Apuntar Z a la tabla
    ldi ZH, HIGH(table7seg<<1)
    ldi ZL, LOW(table7seg<<1)
    
    // Agregar offset del contador a Z
    add ZL, r17
    ldi r16, 0
    adc ZH, r16
    
    // Leer valor de la tabla
    lpm r16, Z
    
    // Mostrar en PORTD (solo bits 0-6)
    andi r16, 0b01111111
    out PORTD, r16

    pop r31
    pop r30
    pop r17
    pop r16
    ret

Delay_100ms:
    push temp
    
    ldi temp, 158
    out TCNT0, temp

Overflow:
    sbis TIFR0, TOV0
    rjmp Overflow

    ldi temp, (1<<TOV0)
    out TIFR0, temp

    pop temp
    ret

Delay_50ms:
    push r16
    push r17
    push r18

    // F_cpu = 1MHz
    // Necesitamos ~50,000 ciclos para 50ms
    ldi r18, 200

Delay_outer:
    ldi r17, 250

Delay_inner:
    dec r17
    brne Delay_inner
    
    dec r18
    brne Delay_outer

    pop r18
    pop r17
    pop r16
    ret
